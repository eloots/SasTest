/**
 * Copyright 2015 Eric Loots
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.sequoia.sastest

import java.io.File

import com.sequoia.sastest.SASInterfaceHelpers._
import com.sequoia.sastest.tablerowspecs._
import scala.language.postfixOps

case class Config(noMissingValueFields: Seq[String] = Seq.empty[String],
                  numericFieldTypes: Map[String, String] = Map.empty[String, String],
                  sasTable: String = "",
                  caseClassName: String = "")

object cmdLineOptParsing {
  val parser = new scopt.OptionParser[Config]("genSASFieldSpec") {
    head("genSASFieldSpec", "0.1")
    opt[Seq[String]]('M', "noMissingValueFields")
      .valueName("<fieldName1>,<fieldName2>...")
      .action { (x, c) => c.copy(noMissingValueFields = x)}
      .text("Fields that shouldn't have missing values")

    opt[Map[String, String]]('T', "sasNumericFieldTypes")
      .valueName("<fieldName1=Type1>,<fieldName2=Type2>...")
      .action { (x, c) => c.copy(numericFieldTypes = x)}
      .text("SAS numeric Field type mapping")

    arg[String]("SAS_TableName")
      .required()
      .action { (x, c) => c.copy(sasTable = x) }
      .text("Name of the SAS table name from which to generate Scala case class and companion object")

    arg[String]("ScalaCaseClassName")
      .required()
      .action { (x, c) => c.copy(caseClassName = x) }
      .text("Name of the Scala case class and companion object")

    help("help") text("prints this usage text")
  }

  def parseCmdArgs(args: Array[String]): Option[Config] = {
    parser.parse(args, Config())
  }
}

case object SASContentTableRow extends SASDataRowSpec {
  /*
   * Table structure generated by SAS PROC CONTENTS out=SomeTable
   * Note that we only utilize a limited number of columns in this table
   */
  def sasFieldSpec = List(
    FieldSpec(
      sasFieldName = "libname",
      inputFieldType = InputCharacterField,
      sasFieldLength = "$8.",
      sasFieldType = SASCharacterField),
    FieldSpec(
      sasFieldName = "memname",
      inputFieldType = InputCharacterField,
      sasFieldLength = "$32.",
      sasFieldType = SASCharacterField),
    FieldSpec(
      sasFieldName = "name",
      inputFieldType = InputCharacterField,
      sasFieldLength = "$32.",
      sasFieldType = SASCharacterField),
    FieldSpec(
      sasFieldName = "type",
      inputFieldType = InputNumericField,
      sasFieldType = SASNumericField),
    FieldSpec(
      sasFieldName = "length",
      inputFieldType = InputNumericField,
      sasFieldType = SASNumericField),
    FieldSpec(
      sasFieldName = "format",
      inputFieldType = InputCharacterField,
      sasFieldLength = "$32.",
      sasFieldType = SASCharacterField),
    FieldSpec(
      sasFieldName = "informat",
      inputFieldType = InputCharacterField,
      sasFieldLength = "$32.",
      sasFieldType = SASCharacterField),
    FieldSpec(
      sasFieldName = "formatl",
      inputFieldType = InputNumericField,
      sasFieldType = SASNumericField),
    FieldSpec(
      sasFieldName = "formatd",
      inputFieldType = InputNumericField,
      sasFieldType = SASNumericField),
    FieldSpec(
      sasFieldName = "varnum",
      inputFieldType = InputNumericField,
      sasFieldType = SASNumericField),
    FieldSpec(sasFieldName = "memlabel"),
    FieldSpec(sasFieldName = "typemem"),
    FieldSpec(sasFieldName = "label"),
    FieldSpec(sasFieldName = "informl"),
    FieldSpec(sasFieldName = "informd"),
    FieldSpec(sasFieldName = "just"),
    FieldSpec(sasFieldName = "npos"),
    FieldSpec(sasFieldName = "nobs"),
    FieldSpec(sasFieldName = "engine"),
    FieldSpec(sasFieldName = "crdate"),
    FieldSpec(sasFieldName = "modate"),
    FieldSpec(sasFieldName = "delobs"),
    FieldSpec(sasFieldName = "idxusage"),
    FieldSpec(sasFieldName = "memtype"),
    FieldSpec(sasFieldName = "idxcount"),
    FieldSpec(sasFieldName = "protect"),
    FieldSpec(sasFieldName = "flags"),
    FieldSpec(sasFieldName = "compress"),
    FieldSpec(sasFieldName = "reuse"),
    FieldSpec(sasFieldName = "sorted"),
    FieldSpec(sasFieldName = "sortedby"),
    FieldSpec(sasFieldName = "charset"),
    FieldSpec(sasFieldName = "collate"),
    FieldSpec(sasFieldName = "informd"),
    FieldSpec(sasFieldName = "informd"),
    FieldSpec(sasFieldName = "nodupkey"),
    FieldSpec(sasFieldName = "noduprec"),
    FieldSpec(sasFieldName = "encrypt"),
    FieldSpec(sasFieldName = "pointobs"),
    FieldSpec(sasFieldName = "genmax"),
    FieldSpec(sasFieldName = "gennum"),
    FieldSpec(sasFieldName = "gennext"),
    FieldSpec(sasFieldName = "transcod")
  )

  val fieldIndexes: Map[String, Int] = {
    sasFieldSpec
      .map (_.sasFieldName)
      .zipWithIndex
      .toMap
  }

  val arity = sasFieldSpec.length
}

case class SASContentTableRow(libname: String,
                              memName: String,
                              name: String,
                              colType: Long,
                              length: Long,
                              format: String,
                              inFormat: String,
                              formatLength: Long,
                              formatDecimal: Long,
                              varNum: Long
                             )

object GenerateSASFieldSpecHelpers {

  case class ProcContentsRetrievalError(sasLog: String) extends IllegalStateException(sasLog)

  def generateFieldSpecCodeElements(columnSpecs: List[SASContentTableRow]): List[String] = {
    columnSpecs map {
      case SASContentTableRow(_, _, colName, 1, _, format, "", formatLength, formatDecimal, _) =>
        if (format != "")
          s"""FieldSpec(sasFieldName = "${colName}", inputFieldType = InputNumericField, sasFieldFormat = "${format}")"""
        else
          s"""FieldSpec(sasFieldName = "${colName}", inputFieldType = InputNumericField)"""
      case SASContentTableRow(_, _, colName, 1, _, format, inFormat, formatLength, formatDecimal, _) =>
        if (format != "")
          s"""FieldSpec(sasFieldName = "${colName}", inputFieldType = InputCharacterField, sasFieldInformat = "${inFormat}${formatLength}.", sasFieldFormat = "${format}${formatLength}.")"""
        else
          s"""FieldSpec(sasFieldName = "${colName}", inputFieldType = InputCharacterField, sasFieldInformat = "${inFormat}${formatLength}.")"""
      case SASContentTableRow(_, _, colName, 2, length, _, _, formatLength, formatDecimal, _) =>
        s"""FieldSpec(sasFieldName = "${colName}", inputFieldType = InputCharacterField, sasFieldLength = "$$${length}.", sasFieldType = SASCharacterField)"""
    }
  }

  def generateCaseClassFields(columnSpecs: List[SASContentTableRow],
                              noMissingValueFields: Set[String],
                              numericFieldTypes: Map[String, String] ): List[String] = {
    columnSpecs map {
      case SASContentTableRow(_, _, colName, 1, _, "DATE", _, formatLength, formatDecimal, _) =>
        if (noMissingValueFields contains colName)
          s"""$colName: ${numericFieldTypes.getOrElse(colName, "LocalDate")}"""
        else
          s"""$colName: Option[${numericFieldTypes.getOrElse(colName, "LocalDate")}] = None"""

      case SASContentTableRow(_, _, colName, 1, _, format, "", formatLength, formatDecimal, _) =>
        if (noMissingValueFields contains colName)
          s"""$colName: ${numericFieldTypes.getOrElse(colName, "Long")}"""
        else
          s"""$colName: Option[${numericFieldTypes.getOrElse(colName, "Long")}] = None"""

      case SASContentTableRow(_, _, colName, 2, length, _, _, formatLength, formatDecimal, _) =>
        if (noMissingValueFields contains colName)
          s"""$colName: String"""
        else
          s"""$colName: Option[String] = None"""

    }
  }

  def generateCaseClassDelimStringFields(columnSpecs: List[SASContentTableRow],
                                         noMissingValueFields: Set[String],
                                         numericFieldTypes: Map[String, String] ): List[String] = {
    columnSpecs map {
      case SASContentTableRow(_, _, colName, 1, _, "DATE", _, formatLength, formatDecimal, _) =>
        s"""$${formattedDate($colName, DATE$formatLength${if (formatDecimal == 0) "" else s"_${formatDecimal}" })}"""

      case SASContentTableRow(_, _, colName, _, _, _, _, formatLength, formatDecimal, _) =>
        if (noMissingValueFields contains colName)
          s"""$${$colName}"""
        else
          s"""$${$colName.getOrElse("")}"""
    }
  }

  def gen(columnSpecs: List[SASContentTableRow],
          noMissingValueFields: Set[String],
          numericFieldTypes: Map[String, String] ): List[String] = {
    (columnSpecs zipWithIndex) map {
      case (SASContentTableRow(_, _, colName, 1, _, "DATE", _, formatLength, formatDecimal, varNum), index) =>
        if (noMissingValueFields contains colName) {
          s"""Date$formatLength(values(columnMapping(${index}))).toLocalDate"""
        } else {
          s"""if (values(columnMapping(${index})) == "") None else Some(Date$formatLength(values(columnMapping(${index}))).toLocalDate)"""
        }
      case (SASContentTableRow(_, _, colName, 1, _, _, _, formatLength, formatDecimal, varNum), index) =>
        if (noMissingValueFields contains colName) {
          s"""values(columnMapping(${index})).to${numericFieldTypes.getOrElse(colName, "Long")}"""
        } else {
          s"""if (values(columnMapping(${index})) == "") None else Some(values(columnMapping(${index})).to${numericFieldTypes.getOrElse(colName, "Long")})"""
        }
      case (SASContentTableRow(_, _, colName, 2, _, _, _, formatLength, formatDecimal, varNum), index) =>
        if (noMissingValueFields contains colName) {
          s"""values(columnMapping(${index}))"""
        } else {
          s"""if (values(columnMapping(${index})) == "") None else Some(values(columnMapping(${index})))"""
        }
    }
  }
}

object GenerateSASFieldSpec {
  import GenerateSASFieldSpecHelpers._

  def main(args: Array[String]): Unit = {
    import cmdLineOptParsing._

    val cmd = s"""genSASFieldSpec ${args.toList.mkString(" ")}"""

    val parsedArgs = parseCmdArgs(args)

    if (parsedArgs == None) System.exit(-1)

    val Some(Config(noMissingValueFields_, numericFieldTypes_, tableFullName, tableName)) = parsedArgs
    val noMissingValueFields = noMissingValueFields_ map (_.toLowerCase)
    val numericFieldTypes = numericFieldTypes_ map { case (k, v) => k.toLowerCase -> v}
    val (columnMapping, rawOutputData) = if (tableFullName endsWith(".csv")) {
      val rawOutputData = new FileLineTraversable(new File(tableFullName)).map(_.split("\t", SASContentTableRow.arity)).toList
      val columnMapping = (rawOutputData.head.zipWithIndex.map {case (fld, index) => SASContentTableRow.fieldIndexes(fld.toLowerCase) -> index}).toMap
      (columnMapping, rawOutputData)
    } else {
      implicit val SASContext(sasLanguage, ctx, adm) =
        sasContext(SASConfig.sasHostname, SASConfig.sasPort, SASConfig.sasUsername, SASConfig.sasPassword)

      val sasContentTable = "WORK.SAS_CONTENT"
      val sasCode =
        s"""libname SBTVPDAT "/opt/SAS/projects/SBI/TrainingVAjan2014/PRD/Data";
           |proc contents data=${tableFullName} out=${sasContentTable} noprint;run;
                                                                        |""".stripMargin

      val SASLoggingOutput(sasLog) = executeSASquery(sasLanguage, sasCode)
      if (("ERROR".r findFirstIn(sasLog)) != None) throw ProcContentsRetrievalError(sasLog)

      val TestOutput(_, columnMapping, rawOutputData) =
        retrieveSasTable(sasContentTable, SASContentTableRow)
      ctx.close()
      adm.shutdown()
      (columnMapping, rawOutputData)
    }

    val columnSpecs = rawOutputData.tail
      .map {
      case values =>
        SASContentTableRow(
          libname       = values(columnMapping(0)),
          memName       = values(columnMapping(1)),
          name          = values(columnMapping(2)).toLowerCase, // Map all column name to lowercase for further processing
          colType       = values(columnMapping(3)).toLong,
          length        = values(columnMapping(4)).toLong,
          format        = values(columnMapping(5)),
          inFormat      = values(columnMapping(6)),
          formatLength  = values(columnMapping(7)).toLong,
          formatDecimal = values(columnMapping(8)).toLong,
          varNum        = values(columnMapping(9)).toLong
        )
    } sortBy(_.varNum)

    val sasTableFieldList = columnSpecs.map(_.name.toLowerCase)
    val sasTableFieldSet = sasTableFieldList.toSet

    def checkUnknownFields(specifiedFieldNames: Set[String], knownFieldNames: Set[String], errorMsg: String) = {
      val unknownFields = specifiedFieldNames &~ knownFieldNames
      if (unknownFields nonEmpty) {
        System.err.println(s"""$errorMsg:\n${unknownFields.mkString("  ", "\n  ", "\n")}""")
        System.exit(0)
      }
    }

    checkUnknownFields(noMissingValueFields.toSet, sasTableFieldSet, "Unknown field(s) in 'noMissingValueFields' specification")
    checkUnknownFields(numericFieldTypes.keys.toSet, sasTableFieldSet, "Unknown field(s) in 'sasNumericFieldTypes' specification")

    val inputItems = generateFieldSpecCodeElements(columnSpecs)
    val caseClassFields = generateCaseClassFields(columnSpecs, noMissingValueFields.toSet, numericFieldTypes)
    val caseClassDelimStringFields = generateCaseClassDelimStringFields(columnSpecs, noMissingValueFields.toSet, numericFieldTypes)
    val rawToCaseClassMapping = gen(columnSpecs, noMissingValueFields.toSet, numericFieldTypes)

    val code = s"""
       |// Code generated with following command:
       |//
       |//   $cmd
       |//
       |// ----- Generated code BEGIN -----
       |import com.sequoia.sastest._
       |import com.sequoia.sastest.formats.Formats._
       |import java.time.LocalDate
       |
       |case object ${tableName} extends SASDataRowSpec {
       |  def sasFieldSpec = List(
       |  ${inputItems.mkString("  ", ",\n    ", ")")}
       |
       |  val fieldIndexes: Map[String, Int] = {
       |    sasFieldSpec
       |      .map (_.sasFieldName)
       |      .zipWithIndex
       |      .toMap
       |  }
       |
       |  val arity = sasFieldSpec.length
       |
       |  def mapRawTo${tableName}(data: OutputData, columnMapping: ColumnMapping): List[${tableName}] = {
       |    data map { values => ${tableName}(
       |        ${rawToCaseClassMapping.mkString("", ",\n        ", "")})
       |      }
       |  }
       |}
       |
       |case class $tableName(${caseClassFields.mkString(", ")}) extends SASDataRowType {
       |  def toDelimString: String = s""\"${caseClassDelimStringFields.mkString("\\t")}""\"
       |}
       |// ----- Generated code END   -----
     """.stripMargin

    val codeFilename = s"../${tableName}.scala"
    DelimitedFileRW.writeDelimitedFile(List(code), codeFilename)
    println(s"""Generated code written to file: $codeFilename""")
  }

}
